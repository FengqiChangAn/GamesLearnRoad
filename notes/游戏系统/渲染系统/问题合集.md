
### WebGL 运行在 GPU 中

> WebGL 运行在 GPU 中，因此需要使用能够在 GPU 上运行的程序。这样的程序需要成对提供，每对方法中都包含一个顶点着色器和一个片段着色器，并且使用 GLSL 语言（GL 着色语言）编写。每对组合起来称作一个 program（着色程序）

 **问：** 什么叫能够在GPU上运行的程序？成对提供是什么意思？每对方法中都包含一个顶点着色器和一个片段着色器？又是怎么样运行在GPU中的？

**答：**

1. 什么叫能够在GPU上运行的程序？

CPU 和 GPU 是完全不同的硬件架构：

* CPU 擅长 **串行、复杂逻辑** （比如循环、分支、业务逻辑），运行的是 JavaScript、C++ 等 “通用编程语言”；
* GPU 擅长 **并行**  **、简单重复计算** （比如同时处理成千上万个顶点 / 像素），但它**无法直接运行 ** **JavaScript** ，只能运行专门为其设计的、高度精简的编程指令集 —— 也就是**GLSL（OpenGL 着色语言）编写的****着色器** **程序** 。

“能够在 GPU 上运行的程序” 本质是：

> 符合 GPU 硬件指令集规范（GLSL 语法）、被编译成 GPU 可执行二进制码的着色器代码，而非 CPU 端的通用代码。

WebGL 的核心作用就是 “桥接”：把你写的 GLSL 代码传给 GPU，编译成 GPU 能执行的指令，再调度 GPU 执行这些指令。

2. 成对提供是什么意思？

WebGL（底层是 OpenGL ES）规定：**任何可执行的 ****GPU**** 渲染程序，必须同时包含 “顶点** **着色器** **” 和 “片段着色器”** —— 二者缺一不可，必须成对编译、链接成一个完整的 “着色程序（Program）”，才能被 GPU 执行。

再问：为什么必须要编译、链接成一个完整的着色程序？

编译的核心目的：把人类可读的 GLSL 源码，转换成 GPU 硬件能直接执行的二进制指令

顶点着色器和片段着色器不是孤立的 —— 顶点着色器会把数据（比如顶点颜色、纹理坐标）传递给片段着色器，而链接的核心作用就是：

* 解析两个着色器之间的 **接口匹配性** （比如顶点着色器输出的 `varying vec3 v_Color`，片段着色器是否声明了同名同类型的 `varying vec3 v_Color`接收）；
* 分配 GPU 资源（比如显存地址、寄存器），把两个编译后的着色器指令 “拼接” 成一个完整的、可调度的渲染程序；

> WebGL 底层基于 OpenGL ES，其固定渲染管线（Fixed Pipeline）早已被可编程管线（Programmable Pipeline）取代 —— 可编程管线的核心规则就是：**只有链接后的完整 Program，才能被 ****GPU** ** 的渲染管线调度执行** 。单独的顶点着色器 / 片段着色器，既无法被激活（`gl.useProgram`只认 Program），也无法触发渲染（`gl.drawArrays`需要激活的 Program）。

3. 每对方法中都包含一个顶点着色器和一个片段着色器？

“每对方法包含一个顶点着色器和一个片段着色器” 的说法不够精准 —— 它们不是 “方法”，而是 **两个独立的 GLSL 程序模块** ，分工处理渲染的两个核心阶段：

| 着色器类型 | 核心作用                                                             | 处理对象                           | 并行特性         |
| ---------- | -------------------------------------------------------------------- | ---------------------------------- | ---------------- |
| 顶点着色器 | 计算顶点的最终位置（坐标变换、投影、动画等），并传递数据给片段着色器 | 每个顶点（如三角形的 3 个顶点）    | 每个顶点并行执行 |
| 片段着色器 | 计算每个像素的最终颜色（纹理采样、光照、透明度等）                   | 每个像素（如三角形覆盖的所有像素） | 每个像素并行执行 |

4. 又是怎么样运行在GPU中的？

步骤 1：编写 GLSL 代码（CPU 端）

步骤 2：CPU 端编译 / 链接着色器（WebGL API 操作）

1. 创建顶点着色器对象 + 片段着色器对象；
2. 将 GLSL 代码传入对应着色器对象，调用 `gl.compileShader()`编译（GPU 把 GLSL 转成自身可执行的二进制指令）；
3. 创建 “着色程序（Program）” 对象，把编译后的两个着色器对象附加到 Program 上；
4. 调用 `gl.linkProgram()`链接 ——GPU 将两个着色器的输入输出打通（比如顶点着色器传递的颜色数据，片段着色器能接收），形成完整的可执行程序

步骤 3：GPU 执行程序（并行计算）

1. CPU 通过 WebGL API 把顶点数据（如三角形的 3 个坐标）传入 GPU 的显存；
2. 调用 `gl.useProgram(program)`激活这个 Program；
3. 调用 `gl.drawArrays()`/`gl.drawElements()`触发 GPU 渲染：
   1. **顶点着色器** **阶段** ：GPU 的多个 “顶点处理器” 并行处理每个顶点，计算最终位置；
   2. **光栅化** **阶段** ：GPU 根据顶点位置，计算出图形覆盖的所有像素（生成 “片段”）；
   3. **片段着色器** **阶段** ：GPU 的多个 “片段处理器” 并行处理每个像素，计算最终颜色；
   4. **输出阶段** ：GPU 把计算好的像素颜色写入帧缓冲区，最终显示在屏幕上。

总结：了解WebGL的概念、作用原理、作用流程，并能够需要根据原理和流程自主编写着色器程序。
