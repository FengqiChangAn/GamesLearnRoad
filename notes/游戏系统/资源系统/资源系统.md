# 资源系统设计

## 设计目标

资源系统是游戏引擎的核心模块之一，负责统一管理游戏中的所有资源（纹理、音频、预制体、场景等）。本系统旨在提供：

- **统一的资源加载接口**：屏蔽本地/远程加载差异，提供一致的API
- **高效的资源管理**：通过引用计数机制，自动管理资源生命周期
- **灵活的加载策略**：支持预加载、优先级队列、资源热更新
- **完善的版本管理**：支持资源版本控制和增量更新

## 系统架构

资源系统采用三层架构设计：

```
┌─────────────────────────────────────────┐
│          AssetLoader (加载层)            │
│  - 本地资源加载                          │
│  - 远程资源加载                          │
│  - 预加载队列管理                        │
│  - 优先级调度                            │
│  - 版本管理                              │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│        AssetManager (管理层)             │
│  - 资源缓存                              │
│  - 引用计数                              │
│  - 资源查找                              │
│  - 资源使用追踪                          │
└──────────────┬──────────────────────────┘
               │
               ↓
┌─────────────────────────────────────────┐
│        AssetRelease (释放层)             │
│  - 自动释放策略                          │
│  - 手动释放接口                          │
│  - 依赖关系管理                          │
└─────────────────────────────────────────┘
```

### 数据流向

1. **加载流程**：`AssetLoader` → `AssetManager`（加载完成后注册到管理器）
2. **使用流程**：`AssetManager` → 业务代码（通过引用计数追踪使用）
3. **释放流程**：`AssetRelease` ← `AssetManager`（引用计数为0时触发释放）

## 核心模块

### 1. AssetLoader（资源加载器）

**职责**：
- 提供统一的资源加载接口
- 区分本地资源和远程资源
- 管理预加载队列和优先级
- 处理资源版本检查和更新

**设计原则**：
- 单一职责：只负责加载，不管理资源状态
- 可扩展性：支持通过继承实现特殊资源加载器（如Zip资源）
- 异步加载：所有加载操作均为异步，避免阻塞主线程

**核心接口**：

```typescript
// 加载单个资源
loadAsset(path: string, options?: LoadOptions): Promise<cc.Asset>

// 预加载资源（支持优先级）
preloadAssets(paths: string[], priority?: number): Promise<void>

// 检查资源版本
checkVersion(path: string): Promise<VersionInfo>

// 更新资源
updateAsset(path: string, version: string): Promise<void>
```

**加载策略**：
- 本地资源：通过 `cc.AssetManager.Bundle` 加载
- 远程资源：通过 `cc.AssetManager.loadRemote` 加载
- 自动识别：根据路径前缀（`http://` 或 `https://`）判断资源类型

### 2. AssetManager（资源管理器）

**职责**：
- 维护资源缓存池
- 管理资源引用计数
- 提供资源查找接口
- 追踪资源使用情况

**设计原则**：
- 单例模式：全局唯一实例，统一管理所有资源
- 引用计数：每个资源维护引用计数，确保资源正确释放
- 缓存策略：已加载的资源缓存在内存中，避免重复加载

**核心接口**：

```typescript
// 获取资源（自动增加引用计数）
getAsset(path: string): Promise<cc.Asset>

// 释放资源引用（减少引用计数）
releaseAsset(path: string): void

// 查找资源
findAsset(path: string): cc.Asset | null

// 获取引用计数
getRefCount(path: string): number
```

**引用计数机制**：
- 每次 `getAsset` 调用，引用计数 +1
- 每次 `releaseAsset` 调用，引用计数 -1
- 引用计数为 0 时，触发自动释放流程

### 3. AssetRelease（资源释放器）

**职责**：
- 实现资源释放策略
- 处理资源依赖关系
- 提供手动释放接口
- 管理资源生命周期

**设计原则**：
- 自动释放：引用计数为0时自动释放
- 依赖管理：释放资源时，同时释放其依赖资源
- 延迟释放：支持延迟释放策略，避免频繁的内存分配/释放

**核心接口**：

```typescript
// 自动释放（引用计数为0时调用）
autoRelease(path: string): void

// 手动释放（强制释放，忽略引用计数）
forceRelease(path: string): void

// 释放所有资源
releaseAll(): void

// 设置释放策略
setReleaseStrategy(strategy: ReleaseStrategy): void
```

**释放策略**：
- **立即释放**：引用计数为0时立即释放
- **延迟释放**：引用计数为0后，延迟一定时间再释放（适合频繁使用的资源）
- **手动释放**：完全由业务代码控制释放时机

## 资源生命周期

```
加载阶段 → 使用阶段 → 释放阶段
   ↓          ↓          ↓
AssetLoader  AssetManager  AssetRelease
```

1. **加载阶段**：通过 `AssetLoader` 加载资源，加载完成后注册到 `AssetManager`
2. **使用阶段**：通过 `AssetManager.getAsset` 获取资源，自动增加引用计数
3. **释放阶段**：通过 `AssetManager.releaseAsset` 减少引用计数，计数为0时触发 `AssetRelease` 释放

## 资源版本管理

### 版本信息结构

```typescript
interface VersionInfo {
    version: string;        // 版本号
    size: number;           // 资源大小
    md5: string;           // 资源MD5值
    updateTime: number;    // 更新时间戳
}
```

### 版本检查流程

1. 加载资源前，检查本地版本信息
2. 与远程版本信息对比
3. 如果版本不一致，下载新版本资源
4. 更新本地版本信息

### 热更新支持

- 支持增量更新：只下载变更的资源
- 支持版本回滚：保留旧版本资源，支持快速回滚
- 支持断点续传：下载失败后支持断点续传

## 预加载机制

### 优先级队列

资源预加载支持优先级设置，高优先级资源优先加载：

```typescript
// 优先级定义
enum LoadPriority {
    LOW = 0,      // 低优先级
    NORMAL = 1,   // 普通优先级
    HIGH = 2,     // 高优先级
    CRITICAL = 3  // 关键优先级
}
```

### 预加载策略

- **队列加载**：按优先级顺序加载资源
- **并发控制**：限制同时加载的资源数量，避免内存峰值
- **进度回调**：提供加载进度回调，方便显示加载进度

## 使用示例

### 基本使用

```typescript
// 1. 加载资源
const asset = await AssetLoader.loadAsset('textures/hero.png');
const sprite = node.getComponent(cc.Sprite);
sprite.spriteFrame = new cc.SpriteFrame(asset);

// 2. 通过管理器获取（自动管理引用计数）
const asset = await AssetManager.getInstance().getAsset('textures/hero.png');

// 3. 释放资源
AssetManager.getInstance().releaseAsset('textures/hero.png');
```

### 预加载使用

```typescript
// 预加载资源列表
const preloadList = [
    'textures/hero.png',
    'audio/bgm.mp3',
    'prefabs/enemy.prefab'
];

// 高优先级预加载
await AssetLoader.preloadAssets(preloadList, LoadPriority.HIGH);
```

### 版本管理使用

```typescript
// 检查资源版本
const versionInfo = await AssetLoader.checkVersion('textures/hero.png');

// 如果需要更新
if (versionInfo.needUpdate) {
    await AssetLoader.updateAsset('textures/hero.png', versionInfo.latestVersion);
}
```

## 扩展性设计

### 自定义加载器

特殊资源类型可以通过继承 `AssetLoader` 实现自定义加载逻辑：

```typescript
class ZipAssetLoader extends AssetLoader {
    async loadAsset(path: string, options?: LoadOptions): Promise<cc.Asset> {
        // 自定义Zip资源加载逻辑
        // ...
    }
}
```

## 性能优化

1. **资源缓存**：已加载的资源缓存在内存中，避免重复加载
2. **异步加载**：所有加载操作异步执行，不阻塞主线程
3. **并发控制**：限制同时加载的资源数量，控制内存峰值
4. **延迟释放**：支持延迟释放策略，减少频繁的内存分配/释放
5. **资源池**：常用资源可以放入资源池，避免频繁加载/释放

## 注意事项

1. **引用计数管理**：使用资源后必须调用 `releaseAsset` 释放引用，避免内存泄漏
2. **资源路径规范**：统一使用相对路径或完整URL，避免路径不一致导致的问题
3. **版本管理**：生产环境必须启用版本管理，确保资源更新正确
4. **错误处理**：加载失败时要有完善的错误处理和重试机制
5. **内存监控**：定期检查资源缓存大小，避免内存溢出
