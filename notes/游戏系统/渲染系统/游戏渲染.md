# 游戏渲染

我们知道，如果说一个游戏需要渲染一千个对象、或者更多，那么传统的去实例化创建预制体就很行不通了
你们为什么实例化大量的预制体就行不通了呢？原因很多

1. 每次 Instantiate() 都会在堆内存分配新对象，大量实例化会产生海量临时内存碎片；销毁时 Destroy() 又会触发 GC（垃圾回收），GC 执行时引擎会暂停所有逻辑，导致帧率骤降甚至卡死。
   为什么GC执行时引擎会暂停所有逻辑？
2. 我们知道，预制体本质上就是序列化数据，每个预制体实例都会占用内存（组件数据、纹理 / 材质引用、脚本变量等），即使是简单的立方体，几千个实例也会占用大量内存；若预制体包含高分辨率纹理、音频、动画片段，内存会快速打满，触发系统强制杀进程。

所以当我们无法通过实例化预制体的方式去渲染一千个对象时，我们就需要一种更加高效合乎性能的方式去完成，而这种方式就是自定义渲染管线
而完成这个过程其实很简单，第一步就是准备好这一千个对象的顶点数据，第二步就是准备好这一千个对象的纹理，然后就是交给引擎的渲染管线去负责渲染

3.8:

1. 渲染组件，继承自UIRender，提供渲染数据
2.
